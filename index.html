<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Glitch Area - Infiltration</title>
    <link rel="icon" href="glitch-area.vercel.app/icon.png">
    <style>
        body { margin: 0; overflow: hidden; background: black; color: white; font-family: 'Courier New', Courier, monospace; }
        #menu, #gameOver, #win {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.9); z-index: 10; text-align: center;
        }
        button { 
            padding: 15px 40px; font-size: 20px; cursor: pointer; 
            background: transparent; color: #00ff00; border: 2px solid #00ff00;
            transition: 0.3s;
        }
        button:hover { background: #00ff00; color: black; box-shadow: 0 0 20px #00ff00; }
        #hud { position: absolute; top: 20px; left: 20px; z-index: 15; font-size: 20px; color: #00ff00; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; background: url("viseur.png") no-repeat center;
            background-size: contain; pointer-events: none; display: none; z-index: 11;
        }
        #crosshair::before {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 10px; height: 10px; border: 1px solid #00ff00; border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #maskOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, transparent 40%, black 90%);
            display: none; pointer-events: none; z-index: 6;
        }
    </style>
</head>
<body>

<div id="menu">
    <h1 style="font-size: 50px; letter-spacing: 10px; color: #00ff00;">GLITCH AREA</h1>
    <p>[ WASD ] to Move | [ Mouse ] to Aim | [ E ] for Shield</p>
    <button id="startBtn">INITIALIZE MISSION</button>
</div>

<div id="gameOver" style="display:none;">
    <h1 style="color: red;">CRITICAL FAILURE</h1>
    <button onclick="location.reload()">REBOOT SYSTEM</button>
</div>

<div id="win" style="display:none;">
    <h1 style="color: #00ff00;">INFILTRATION SUCCESS</h1>
    <button onclick="location.reload()">NEXT SECTOR</button>
</div>

<div id="hud">
    STRUCTURE: <span id="hp">100</span>% <br>
    WAVE: <span id="waveTxt">1</span>
</div>
<div id="crosshair"></div>
<div id="maskOverlay"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
window.onload = function(){
    let scene, camera, renderer;
    let player, cameraPivot;
    let enemies=[], bullets=[], enemyBullets=[];
    let walls=[]; // Contiendra les boîtes de collision des murs
    let keys={}, hp=100, gameStarted=false, wave=1;
    let shield;

    const tempBox = new THREE.Box3();
    const playerBox = new THREE.Box3();

    document.getElementById("startBtn").addEventListener("click", startGame);

    function startGame(){
        document.getElementById("menu").style.display="none";
        document.getElementById("crosshair").style.display="block";
        document.getElementById("maskOverlay").style.display="block";
        init();
        spawnWave();
        gameStarted = true;
        document.body.requestPointerLock();
        animate();
    }

    function init(){
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202);
        scene.fog = new THREE.Fog(0x000000, 10, 70);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.HemisphereLight(0x00ff00, 0x222222, 1.0));

        // Sol
        let floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200, 40, 40),
            new THREE.MeshStandardMaterial({color: 0x050505, wireframe: true})
        );
        floor.rotation.x = -Math.PI/2;
        scene.add(floor);

        // Système de murs avec collision
        let wallTex = new THREE.TextureLoader().load("wall.png");
        function createWall(x, z, w, d){
            let wallGeo = new THREE.BoxGeometry(w, 5, d);
            let wallMat = new THREE.MeshStandardMaterial({map: wallTex, color: 0x113311});
            let wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set(x, 2.5, z);
            scene.add(wall);
            
            // On stocke la boîte de collision du mur
            let box = new THREE.Box3().setFromObject(wall);
            walls.push(box);
        }
        
        // Création du labyrinthe
        for(let i=-30; i<=30; i+=15){
            createWall(i, 0, 2, 25);
            createWall(0, i, 25, 2);
        }

        // Joueur
        player = new THREE.Object3D();
        player.position.set(0, 1.6, 20);
        scene.add(player);

        cameraPivot = new THREE.Object3D();
        player.add(cameraPivot);
        cameraPivot.add(camera);

        shield = new THREE.Mesh(
            new THREE.SphereGeometry(2, 16, 16),
            new THREE.MeshStandardMaterial({color: 0x00ffff, transparent: true, opacity: 0.2, wireframe: true})
        );
        shield.visible = false;
        scene.add(shield);

        document.addEventListener("keydown", e => keys[e.code] = true);
        document.addEventListener("keyup", e => keys[e.code] = false);
        document.addEventListener("keydown", e => {
            if(e.code === "KeyE") shield.visible = !shield.visible;
        });

        let yaw=0, pitch=0;
        document.addEventListener("mousemove", (e) => {
            if(document.pointerLockElement === document.body && gameStarted){
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-1.4, Math.min(1.4, pitch));
                player.rotation.y = yaw;
                cameraPivot.rotation.x = pitch;
            }
        });

        document.addEventListener("mousedown", () => {
            if(gameStarted && document.pointerLockElement === document.body) {
                shoot(camera, bullets, 0x00ff00, 1.5);
            }
        });
    }

    function checkCollision(pos) {
        // Définit une petite boîte autour de la future position du joueur
        playerBox.setFromCenterAndSize(pos, new THREE.Vector3(1, 2, 1));
        for(let wallBox of walls) {
            if(playerBox.intersectsBox(wallBox)) return true;
        }
        return false;
    }

    function shoot(fromObj, array, color, speed){
        let b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: color}));
        fromObj.getWorldPosition(b.position);
        let dir = new THREE.Vector3();
        fromObj.getWorldDirection(dir);
        b.userData.vel = dir.multiplyScalar(speed);
        scene.add(b);
        array.push(b);
    }

    function spawnWave(){
        document.getElementById("waveTxt").textContent = wave;
        for(let i=0; i < wave * 3; i++){
            let e = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 2, 1.2),
                new THREE.MeshStandardMaterial({color: 0xff0000, wireframe: true})
            );
            e.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60 - 20);
            e.userData = { cool: 100 };
            scene.add(e);
            enemies.push(e);
        }
    }

    function animate(){
        if(!gameStarted) return;
        requestAnimationFrame(animate);

        let speed = 0.15;
        let move = new THREE.Vector3();
        let forward = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
        let right = new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion);

        if(keys["KeyW"]) move.add(forward);
        if(keys["KeyS"]) move.sub(forward);
        if(keys["KeyA"]) move.sub(right);
        if(keys["KeyD"]) move.add(right);
        
        if(move.length() > 0){
            move.normalize().multiplyScalar(speed);
            
            // Test de collision sur l'axe X puis Z pour permettre de glisser contre les murs
            let nextPos = player.position.clone();
            
            // Test X
            nextPos.x += move.x;
            if(!checkCollision(nextPos)) {
                player.position.x = nextPos.x;
            } else {
                nextPos.x = player.position.x;
            }

            // Test Z
            nextPos.z += move.z;
            if(!checkCollision(nextPos)) {
                player.position.z = nextPos.z;
            }
        }

        shield.position.copy(player.position);

        // Balles Joueur
        for(let i = bullets.length - 1; i >= 0; i--){
            let b = bullets[i];
            b.position.add(b.userData.vel);
            let hit = false;
            for(let j = enemies.length - 1; j >= 0; j--){
                tempBox.setFromObject(enemies[j]);
                if(tempBox.containsPoint(b.position)){
                    scene.remove(enemies[j]);
                    enemies.splice(j, 1);
                    hit = true; break;
                }
            }
            if(hit || b.position.length() > 100){
                scene.remove(b); bullets.splice(i, 1);
            }
        }

        // IA Ennemis
        enemies.forEach(e => {
            e.lookAt(player.position);
            if(e.position.distanceTo(player.position) > 8) e.translateZ(0.04);
            e.userData.cool--;
            if(e.userData.cool <= 0){
                shoot(e, enemyBullets, 0xff0000, 0.4);
                e.userData.cool = 100 + Math.random()*100;
            }
        });

        // Balles Ennemis
        for(let i = enemyBullets.length - 1; i >= 0; i--){
            let b = enemyBullets[i];
            b.position.add(b.userData.vel);
            let dist = b.position.distanceTo(player.position);
            if(shield.visible && dist < 2.2){
                scene.remove(b); enemyBullets.splice(i, 1); continue;
            }
            if(dist < 1.2){
                hp -= 5;
                document.getElementById("hp").textContent = hp;
                scene.remove(b); enemyBullets.splice(i, 1);
                if(hp <= 0) {
                    gameStarted = false;
                    document.getElementById("gameOver").style.display="flex";
                    document.exitPointerLock();
                }
            }
        }

        if(enemies.length === 0 && gameStarted){
            wave++;
            if(wave > 10) {
                document.getElementById("win").style.display="flex";
                gameStarted = false;
            } else { spawnWave(); }
        }

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
};
</script>
</body>
</html>
