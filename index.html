<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Glitch Area - Infiltration</title>
<link rel="icon" href="icon.png">
<style>
body{margin:0;overflow:hidden;background:black;color:white;font-family:Arial;}
#menu,#gameOver,#win{
position:absolute;top:0;left:0;width:100%;height:100%;
display:flex;flex-direction:column;justify-content:center;align-items:center;
background:black;z-index:10;
}
button{padding:15px 30px;font-size:18px;cursor:pointer;}
#hud{position:absolute;top:10px;left:10px;z-index:5;}
#crosshair{
position:absolute;top:50%;left:50%;
transform:translate(-50%,-50%);
width:40px;height:40px;
background:url("viseur.png") no-repeat center;
background-size:contain;
pointer-events:none;display:none;
}

/* ðŸŽ­ MASK EFFECT */
#maskOverlay{
position:absolute;
top:0;left:0;
width:100%;height:100%;
background:radial-gradient(circle at center, transparent 55%, black 100%);
display:none;
pointer-events:none;
z-index:6;
}
</style>
</head>
<body>

<div id="menu">
<h1>GLITCH AREA</h1>
<button onclick="startGame()">Start Mission</button>
</div>

<div id="gameOver" style="display:none;">
<h1>MISSION FAILED</h1>
<button onclick="location.reload()">Retry</button>
</div>

<div id="win" style="display:none;">
<h1>MISSION COMPLETE</h1>
<button onclick="location.reload()">Replay</button>
</div>

<div id="hud">HP: <span id="hp">100</span></div>
<div id="crosshair"></div>
<div id="maskOverlay"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>

let scene, camera, renderer;
let player, cameraPivot;
let enemies=[], bullets=[], enemyBullets=[];
let keys={}, hp=100, gameStarted=false;
let wave=1;

let walls=[];
let shield, shieldHP=100;

// ================= START =================
function startGame(){
document.getElementById("menu").style.display="none";
document.getElementById("crosshair").style.display="block";
init();
gameStarted=true;
document.body.requestPointerLock();
animate();
}

function init(){

scene=new THREE.Scene();
scene.background=new THREE.Color(0x000000);
scene.fog=new THREE.Fog(0x000000,20,100);

camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);

renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// LIGHT
scene.add(new THREE.HemisphereLight(0xffffff,0x222222,1.2));

// FLOOR
let floor=new THREE.Mesh(
new THREE.PlaneGeometry(200,200),
new THREE.MeshStandardMaterial({color:0x111111})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

// ================= WALLS =================
let wallTexture=new THREE.TextureLoader().load("wall.png");

function createWall(x,z,w,h,d){
let wall=new THREE.Mesh(
new THREE.BoxGeometry(w,h,d),
new THREE.MeshStandardMaterial({map:wallTexture})
);
wall.position.set(x,h/2,z);
scene.add(wall);
walls.push(wall);
}

// ArÃ¨ne centrale
createWall(0,-20,40,6,2);
createWall(0,20,40,6,2);
createWall(-20,0,2,6,40);
createWall(20,0,2,6,40);

// ================= PLAYER =================
player=new THREE.Mesh(
new THREE.BoxGeometry(1,2,1),
new THREE.MeshStandardMaterial({color:0x222222})
);
player.position.set(0,1,0);
scene.add(player);

// CAMERA
cameraPivot=new THREE.Object3D();
cameraPivot.position.y=1.5;
player.add(cameraPivot);
cameraPivot.add(camera);
camera.position.set(0,0,0);

// ================= GUN =================
let gun=new THREE.Mesh(
new THREE.BoxGeometry(0.4,0.3,1.5),
new THREE.MeshStandardMaterial({color:0x555555,metalness:1,roughness:0.4})
);
gun.position.set(0.5,-0.3,-1);
camera.add(gun);

// ================= SHIELD =================
shield=new THREE.Mesh(
new THREE.SphereGeometry(2,32,32),
new THREE.MeshStandardMaterial({
color:0x00ffff,
transparent:true,
opacity:0.25
})
);
shield.visible=false;
scene.add(shield);

spawnWave();
}

// ================= CONTROLS =================
document.addEventListener("keydown",e=>{
keys[e.key.toLowerCase()]=true;

if(e.key.toLowerCase()==="e"){
shield.visible=!shield.visible;
}
});

document.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

let yaw=0,pitch=0;
document.addEventListener("mousemove",(e)=>{
if(document.pointerLockElement===document.body && gameStarted){
yaw-=e.movementX*0.002;
pitch-=e.movementY*0.002;
pitch=Math.max(-1.2,Math.min(1.2,pitch));
player.rotation.y=yaw;
cameraPivot.rotation.x=pitch;
}
});

// ================= SHOOT =================
document.addEventListener("mousedown",()=>{
if(!gameStarted) return;

let b=new THREE.Mesh(
new THREE.SphereGeometry(0.15),
new THREE.MeshBasicMaterial({color:0xffffff})
);

b.position.copy(camera.getWorldPosition(new THREE.Vector3()));

let dir=new THREE.Vector3();
camera.getWorldDirection(dir);
b.userData.vel=dir.multiplyScalar(1);

scene.add(b);
bullets.push(b);
});

// ================= SPAWN =================
function spawnWave(){
for(let i=0;i<wave*3;i++){
let e=new THREE.Mesh(
new THREE.BoxGeometry(1.5,2,1.5),
new THREE.MeshStandardMaterial({color:0x000000})
);
e.position.set(
(Math.random()-0.5)*30,
1,
(Math.random()-0.5)*30
);
e.userData.cool=0;
scene.add(e);
enemies.push(e);
}
}

// ================= LOOP =================
function animate(){
requestAnimationFrame(animate);
if(!gameStarted) return;

// MOVEMENT
let forward=new THREE.Vector3();
camera.getWorldDirection(forward);
forward.y=0;
forward.normalize();

let right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0));

let speed=0.15;

let nextPos=player.position.clone();

if(keys["w"]) nextPos.add(forward.clone().multiplyScalar(speed));
if(keys["s"]) nextPos.add(forward.clone().multiplyScalar(-speed));
if(keys["a"]) nextPos.add(right.clone().multiplyScalar(-speed));
if(keys["d"]) nextPos.add(right.clone().multiplyScalar(speed));

// Collision murs joueur
let blocked=false;
walls.forEach(w=>{
let box=new THREE.Box3().setFromObject(w);
if(box.containsPoint(nextPos)) blocked=true;
});
if(!blocked) player.position.copy(nextPos);

shield.position.copy(player.position);

// ================= PLAYER BULLETS =================
bullets.forEach((b,bi)=>{
b.position.add(b.userData.vel);

// collision murs
walls.forEach(w=>{
let box=new THREE.Box3().setFromObject(w);
if(box.containsPoint(b.position)){
scene.remove(b);
bullets.splice(bi,1);
}
});

// collision ennemis
enemies.forEach((e,ei)=>{
let box=new THREE.Box3().setFromObject(e);
if(box.containsPoint(b.position)){
scene.remove(e);
enemies.splice(ei,1);
scene.remove(b);
bullets.splice(bi,1);
}
});
});

// ================= ENEMY AI =================
enemies.forEach(e=>{
e.lookAt(player.position);

let dir=player.position.clone().sub(e.position).normalize();
let move=e.position.clone().add(dir.multiplyScalar(0.03));

// collision murs ennemis
let blocked=false;
walls.forEach(w=>{
let box=new THREE.Box3().setFromObject(w);
if(box.containsPoint(move)) blocked=true;
});
if(!blocked) e.position.copy(move);

e.userData.cool--;
if(e.userData.cool<=0){
let b=new THREE.Mesh(
new THREE.SphereGeometry(0.2),
new THREE.MeshBasicMaterial({color:0xffffff})
);
b.position.copy(e.position);
b.userData.vel=player.position.clone().sub(e.position).normalize().multiplyScalar(0.4);
scene.add(b);
enemyBullets.push(b);
e.userData.cool=120;
}
});

// ================= ENEMY BULLETS =================
enemyBullets.forEach((b,bi)=>{
b.position.add(b.userData.vel);

// collision murs
walls.forEach(w=>{
let box=new THREE.Box3().setFromObject(w);
if(box.containsPoint(b.position)){
scene.remove(b);
enemyBullets.splice(bi,1);
}
});

// shield
if(shield.visible && shieldHP>0){
if(b.position.distanceTo(player.position)<2){
shieldHP-=10;
scene.remove(b);
enemyBullets.splice(bi,1);
if(shieldHP<=0) shield.visible=false;
return;
}
}

// joueur
if(b.position.distanceTo(player.position)<1){
hp-=5;
document.getElementById("hp").textContent=hp;
scene.remove(b);
enemyBullets.splice(bi,1);
if(hp<=0){
document.getElementById("gameOver").style.display="flex";
gameStarted=false;
}
}
});

// NEXT WAVE
if(enemies.length===0){
wave++;
if(wave>5){
document.getElementById("win").style.display="flex";
gameStarted=false;
}else{
spawnWave();
}
}

renderer.render(scene,camera);
}

</script>

</body>
</html>
